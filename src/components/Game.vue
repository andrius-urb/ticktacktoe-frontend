<template>
  <div>
    <div class="grid">
      <div class="row" v-for="x in 3" :key="x">
        <div
          class="cell"
          v-for="n in 3"
          :key="n"
          @click="doClick(x - 1, n - 1)"
        >{{ isItZeroOrCross(items[x-1][n-1]) }}</div>
        <!---->
      </div>
    </div>
    <div v-if="this.gameEnd == true">
      <div v-if="this.winner !== null">{{ (this.winner) ? 'Laimėjo O' : 'Laimėjo X' }}</div>
      <div v-else>Lygiosios!</div>
    </div>
    <br />
    <div>
      <button @click="restart()">Pradėti iš naujo</button>
    </div>
    <br />
    <div class="container">
      <div
        class="row"
        v-for="action in this.actions.slice().reverse()"
        :key="action[2]+'-'+action[0]+'-'+action[1]"
      >{{ (action[2]) ? 'Žaidėjas O' : 'Žaidėjas X' }} padarė veiksmą laukelyje {{ action[0] }}, {{ action[1] }}</div>
    </div>
  </div>
</template>

<script>
import Vue from "vue";
export default {
  name: "Game",
  data() {
    return {
      /**
       * items: kiekvienas masyvo laukelis atspindi žaidimo lentelės laukelį
        |0,0|0,1|0,2|
        |1,0|1,1|1,2| 
        |2,0|2,1|2,2|
        
        * null - laukelis laisvas
        * false - laukelyje X(iksiukas)
        * true  - laukelyje O(nuliukas)
    
       */
      items: [
        [null, null, null],
        [null, null, null],
        [null, null, null],
      ],
      playerTurn: false, // false - X eilė. true - O eilė
      winner: null, // laimėtojas. false - X, true - O, null - nėra laimėtojo.
      gameEnd: false, // true, jei žaidimas baigtas.

      /**
       * TRUE, jei sukelti praeito žaidimo duomenys.
       * FALSE, jei nesukelti.
       * Paleidžiant puslapį kreipiamasi į backend, siekiant rasti buvusius veiksmus ir užpildyti lentelę,
       * jeigu tokių veiksmų buvo rasta. Kol duomenys negauti, šis kintamasi yra FALSE ir neleidžia atlikti jokio
       * veiksmo lentelėje.
       */
      lastGameDataAssigned: false,
      actions: [],
    };
  },
  beforeMount() {
    /**
     * Prieš paleidžiant puslapį, kreipiamės į backend ir ieškome, ar buvo prieš tai atlikta veiksmų.
     * Jeigu veiksmų yra, reiškia žaidimas yra prasidėjęs ir laimėtojas yra arba ne, tačiau žaidimas nebuvo paleistas iš naujo,
     * todėl žaidimas tęsiamas.
     */
    var vm = this;
    this.$api
      .get("actions")
      .then((res) => {
        res.data.forEach(function (tblrow) {
          /**
           * Gautus duomenis iš duomenų bazės priskiriam "actions" kintamajam, kur registruojami atlikti veiksmai.
           * Taip pat, pagal gautus duomenis sudeliojame "items" masyvą, kur registruojama, kuris žaidėjas, kuriame laukelyje
           * atliko veiksmą.
           * Pabaigoje priskiriame playerTurn kintamąjį priešingai reikšmei, negu duomenų bazėje nurodyta, nes jeigu paskutinį veiksmą atliko
           * X žaidėjas, tuomet dabar eilė O žaidėjui. */

          vm.actions.push([tblrow.row, tblrow.column, tblrow.player]);
          Vue.set(vm.items[tblrow.row], tblrow.column, tblrow.player);
          vm.playerTurn = !tblrow.player;
        });
        vm.lastGameDataAssigned = true; // Nurodome, kad praeito žaidimo duomenys sėkmingai sukelti.
      })
      .catch((err) => {
        console.log(err);
      });
  },
  watch: {
    items: {
      handler() {
        // tikriname ar kažkuris žaidėjas laimėjo

        var isX = false; // žaidėjas X masyve "items" žymimas "false"
        var isO = true; // žaidėjas O masyve "items" žymimas "true"
        var checkPlayer = isX; // nurodo, kurį žaidėją tikrina ciklas
        var result = true; // rezultatas, prieš pradedant naują tikrinimą, turi būti "true"

        /**
         * Tikriname įstrižai 0,0  1,1  2,2 laukelius
         */
        for (var b = 0; b < 2; b++) {
          // Šis ciklas pirmą kartą tikrina X žaidėja, antrą kartą O žaidėją.
          result = true;
          if (b == 1) checkPlayer = isO; // ciklas veikia antrą kartą, kuomet tikriname O žaidėją. Priskiriam kintamąjį checkPlayer į isO(true).
          for (var a = 0; a < 3; a++) {
            /**
             * Kadangi kintamasis result = true, tai tikrinant turi būti:
             * result = true && true, tam kad gautume rezultatą jog yra laimėtojas(nes true && true yra TRUE)
             * jeigu sąlyga kitokia, pvž:
             * result = true && false, laimėtojo nėra(nes true && false yra FALSE)
             */
            result = result && this.items[a][a] == checkPlayer;
          }

          if (result) {
            /**
             * result = true, reiškia yra laimėtojas.
             * Laimėtojas bus tas, kurį paskutinį tikrino ciklas. Jį nurodo kintamasis checkPlayer.
             * Perduodame laimėtoją funkcijai.
             */
            return this.gameOver(checkPlayer);
          }
        }

        /**
         * Tikriname įstrižai 2,0  1,1  0,2 laukelius
         */
        checkPlayer = isX;
        for (b = 0; b < 2; b++) {
          result = true;
          if (b == 1) checkPlayer = isO;
          for (a = 0; a < 3; a++) {
            result = result && this.items[2 - a][a] == checkPlayer;
          }
          if (result) {
            return this.gameOver(checkPlayer);
          }
        }

        checkPlayer = isX;
        for (b = 0; b < 2; b++) {
          if (b == 1) checkPlayer = isO;
          for (a = 0; a < 3; a++) {
            result = true;
            for (var c = 0; c < 3; c++) {
              /**
               * Tikrinam linijas
               */
              result = result && this.items[a][c] == checkPlayer;
            }
            if (result) {
              return this.gameOver(checkPlayer);
            }
            result = true;
            for (c = 0; c < 3; c++) {
              /**
               * Tikrinam stulpelius
               */
              result = result && this.items[c][a] == checkPlayer;
            }
            if (result) {
              return this.gameOver(checkPlayer);
            }
          }
        }

        /** Nei viena sąlyga nepatenkinta, reiškia dar nėra laimėtojo,
         * tikriname ar neužimta visi laukeliai
         */
        var count = 0;
        for (a = 0; a < 3; a++) {
          count = count + this.items[a].filter((item) => item === null).length;
          /**
           * Jeigu randa bent vieną "null" reikšmę masyve "items", prie count pridedame rastą kiekį.
           * "null" reikšmė reiškia, kad laukelis neužimtas nei X, nei O */
        }
        if (count == 0) {
          // Jeigu "count" 0, t.y. nėra nei vienos "null" reikšmės masyve "items", reiškia, kad visi laukeliai užimti, ir laimėtojo nėra.
          return this.gameOver(null);
        }
      },
      deep: true,
    },
  },
  methods: {
    /***
     * Funkcija, kuri vykdoma paspaudus ant bet kurio laukelio
     * Parametrai:
     *  x:  Eilutė
     *  n:  Stulpelis
     */
    doClick(x, n) {
      if (!this.lastGameDataAssigned) {
        // Jeigu praeito žaidimo duomenys nesukelti, jeigu tokių buvo, neleisti jokio veiksmo.
        return;
      }

      if (this.gameEnd) {
        // Jeigu žaidimas pasibaigęs, pranešame.
        return alert("Žaidimas baigtas!");
      }
      if (this.items[x][n] !== null) {
        // Jeigu paspaustas laukelis nėra "null", t.y. jau užimtas, pranešame.
        return alert("Laukelis užimtas!");
      }

      // Į "actions" kintamąjį perduodame atliktą veiksmą, kuris žaidėjas, ant kurio laukelio paspaudė.
      this.actions.push([x, n, this.playerTurn]);

      // Pakeičiame masyvo "items" atitinkamoje vietoje reikšmę į false arba true, priklausomai, kurio žaidėjo eilė (this.playerTurn)
      Vue.set(this.items[x], n, this.playerTurn);

      // Siunčiame duomenis į backend, kad įrašytų veiksmą į duomenų bazę
      this.$api
        .post("action", {
          player: this.playerTurn,
          row: x,
          col: n,
        })
        .catch(function (error) {
          console.log(error);
        });

      //  Pakeičiame "playerTurn" kintamąjį į priešingą buvusiam, taip nurodydami, kad dabar kito žaidėjo eilė.
      this.playerTurn = !this.playerTurn;
    },

    /**
     * Funkcija grąžinanti X, O arba jokio rezultato.
     * Parametrai:
     *  value:  Reikšmė, pagal kurią duodamas rezultatas.
     * Galimi variantai:
     *  null:   Grąžina tuščią tekstą
     *  true:   Grąžina "O"
     *  false:  Grąžina "X"
     */
    isItZeroOrCross(value) {
      if (value === null) {
        return "";
      } else {
        if (value) {
          return "O";
        }
        return "X";
      }
    },

    /**
     * Funkcija sustabdanti žaidimą esant laimėtojui arba lygiosioms.
     * Parametrai:
     *  winnerPlayer: Kuris žaidėjas laimėjo
     * Galimi variantai:
     *  true:   Jei laimėjo O
     *  false:  Jei laimėjo X
     *  null:   Jei lygiosios
     */
    gameOver(winnerPlayer) {
      this.winner = winnerPlayer;
      this.gameEnd = true;
    },

    /**
     * Funkcija paleidžianti žaidimą iš naujo.
     */
    restart() {
      // Atstatom kintamuosius į pradinę padėtį.
      this.playerTurn = false;
      this.winner = null;
      this.gameEnd = false;
      for (var a = 0; a < 3; a++) {
        this.items[a].fill(null);
      }
      this.actions = [];

      // Kreipiamės į backend ir ištrinam esančius duomenis apie žaidėjų veiksmus.
      this.$api
        .post("actions", {
          _method: "delete",
        })
        .catch(function (error) {
          console.log(error);
        });
    },
  },
};
</script>

<style>
.grid {
  display: table;
  border-spacing: 0.5px;
  align-items: center;
  justify-content: center;
}
.row {
  display: table-row;
}
.cell {
  width: 50px;
  height: 50px;
  background: white;
  display: table-cell;
  border-color: black;
  border-width: 2px;
  border-style: solid;
  font-size: 45px;
  text-align: center;
}

.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-evenly;
  padding: 10px;
}

.row {
  width: 75%;
  height: 100%;
  background: white;
  border-color: black;
  border-width: 1px;
  border-style: solid;
}
</style>